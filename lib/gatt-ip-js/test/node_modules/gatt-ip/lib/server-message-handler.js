function ServerMessageHandler(gattip) {
    this.processMessage = function (mesg) {
        try {
            var message = JSON.parse(mesg.data);
        } catch (err) {
            console.warn("Got unknown message from client", mesg.data, 'error was', err);
        }
        var obj;

        if ((typeof message === 'undefined') || (!message)) {
            console.warn("Got unknown message from client", mesg.data);
            return;
        }

        if (message.error) {
            console.warn('Error in the Request', mesg.error);
            return;
        }

        // MESSAGE IS VALID

        if (message.result && message.result == C.kMessage) {
            var authenticated = false;
            if (!message.error && typeof message.params == 'object' && message.params.isAuthenticated === true) {
                authenticated = true;
            }
            self.emit('authenticated', authenticated);
            return;
        }
        if (message.request && message.request == C.kMessage) {
            // this is so that clients can talk to us directly, bypassing the proxy. If someone has access to the port, they should authenticate?
            console.log("Client requested to authenticate with us. Allowing the client");
            self.send(JSON.stringify({
                type: C.authenticate,
                isAuthenticated: true
            }));
            return;
        }

        // TODO work out some more invalid message cases....

        var cookie = {id: message.id, session_id: message.session_id};
        var p = message.params;

        switch (message.method) {
            case C.kConfigure:
                // TODO: What are the params?
                self.emit('configure', cookie);
                break;
            case C.kScanForPeripherals:
                // TODO: What are the params?
                self.emit('scan', cookie);
                break;
            case C.kStopScanning:
                // TODO: What are the params?
                self.emit('stopScan', cookie);
                break;
            case C.kCentralState:
                // TODO: What are the params?
                self.emit('getCentralState', cookie);
                break;
            case C.kConnect:
                try {
                    obj = getObjects('P');
                    self.emit('connect', cookie, obj.peripheral.uuid);
                } catch (ex) {
                    console.error(ex);
                }
                break;
            case C.kDisconnect:
                try {
                    obj = self._getObjects('P');
                    self.emit('disconnect', cookie, obj.peripheral.uuid);
                } catch (ex) {
                    console.error(ex);
                }
                break;
            case C.kGetCharacteristicValue:
                try {
                    obj = self._getObjects('C', cookie);
                    self.emit('readCharacteristic', cookie, obj.peripheral.uuid, obj.service.uuid, obj.characteristic.uuid);
                } catch (ex) {
                    console.error(ex);
                }
                break;
            case C.kWriteCharacteristicValue:
                try {
                    obj = self._getObjects('C', cookie);
                    self.emit('writeCharacteristic', cookie, obj.peripheral.uuid, obj.service.uuid, obj.characteristic.uuid, message.params[C.kValue]);
                } catch (ex) {
                    console.error(ex);
                }
                break;
            case C.kSetValueNotification:
                try {
                    (function () {
                        obj = self._getObjects('C', cookie);
                        obj.characteristic.isNotifying = message.params[C.kValue];
                        var cookie = {original:message};
                        self.emit('enableNotifications', cookie, obj.peripheral.uuid, obj.service.uuid, obj.characteristic.uuid, message.params[C.kIsNotifying]);

                    })();
                } catch (ex) {
                    console.error(ex);
                }
                break;
            case C.kGetDescriptorValue:
                try {
                    obj = self._getObjects('D', cookie);
                    self.emit('readDescriptor', cookie, obj.peripheral.uuid, obj.service.uuid, obj.characteristic.uuid, obj.descriptor.uuid);
                } catch (ex) {
                    console.error(ex);
                }
                break;
            case C.kWriteDescriptorValue:
                try {
                    obj = self._getObjects('D', cookie);
                    self.emit('writeDescriptor', cookie, obj.peripheral.uuid, obj.service.uuid, obj.characteristic.uuid, obj.descriptor.uuid, message.params[C.kValue]);
                } catch (ex) {
                    console.error(ex);
                }
                break;

            default:
                console.log('invalid request' + message.method);
                self.sendErrorResponse(cookie, message.method, C.kInvalidRequest, 'Request not handled by server');
                return;
        }
    };
    function buildMessageFromPidCidSic(cookie, message) {
        var params = message.params;
        var pid = cookie.original.params[C.kPeripheralUUID];
        var sid = cookie.original.params[C.kServiceUUID];
        //...
        if (pid) {
            params[C.kPeripheralUUID] = pid;
        }
        if (sid) {
            params[C.kServiceUUID] = sid;
        }
        //
    }
    this.respondToConnect = function(cookie) {
        var params = {};
        buildMessageFromPidCidSic(cookie, params);
        gattip.respond(cookie, params);
    };

    function sampleLinuxGateway(gattip) {
         var smh = gattip.getServerMessageHandler();

         smh.on('enableNotifications', function(cookie, pid, sid, cid, isNotifying) {
             if (iCanNotify() && enableNotify()) {
                 smh.respondToNotify(cookie, isNotifying);
             } else {
                 smh.error(cookie, "Whatever error");
             }
         });
         smh.on('connect', function(cookie, pid) {
             if (iCanNotify) {
                 tryToConnect(pid.uuid);
                 smh.respondToConnect(cookie);
             } else {
                 smh.error(cookie, "Whatever error");
             }
         });
         function onScanFromBluez() {
             smh.scanIndication(device.uuid);
         }
     }
}
